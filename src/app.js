/*
  This is the entry point to our client-side application.
  Everything starts here :)
*/

// Define some global constants. The server defines the opposite values
global.__CLIENT__ = true;
global.__SERVER__ = false;

// SASS is handled by Webpack with sass-loader
import 'APP/assets/styles/toolkit.scss';

import React from 'react';
import {render} from 'react-dom';
import {Router, browserHistory, applyRouterMiddleware} from 'react-router';
import {ReduxAsyncConnect} from 'redux-connect';
import {syncHistoryWithStore} from 'react-router-redux';
import {Provider} from 'react-redux';
import {useScroll} from 'react-router-scroll'

import createRoutes from 'APP/routes';
import makeStore from 'APP/redux/store';

/*
  window.__reduxInitialState can be set by the server in case there was server rendering done.
  If set, it represents the last state of the redux store when the current page was generated by the server.
*/
const store = makeStore(browserHistory, window.__reduxInitialState);

// Any changes in history will be reflected in redux under the routing key.
const history = syncHistoryWithStore(browserHistory, store);
const routes = createRoutes(store);

// Manually loading french data
import {addLocaleData} from 'react-intl';
import frLocaleData from 'react-intl/locale-data/fr';
addLocaleData(frLocaleData);

/*
  The router is wrapped with a provider. This makes it easier to get access to the global state.
  ReduxAsyncConnect kicks off the data loading process -- if any -- right before React and the router want to mount a component.
*/
const app = (
  <Provider store={store}>
    <Router
      render={(props) => (
        <ReduxAsyncConnect
          {...props}
          render={applyRouterMiddleware(useScroll((prevRouterProps, currRouterProps) => {

              //NOTE: In order to correctly handle nested child routes fading in and out we need to make sure
              // that useScroll is only active on top level paths.
              const prevPathname = prevRouterProps && prevRouterProps.location.pathname,
                  currPathname = currRouterProps.location.pathname;
              return prevPathname && !(currPathname.includes(prevPathname) && prevPathname !== '/');
          }))}
        />)
      }
      history={history}
    >
      {routes}
    </Router>
  </Provider>
)

render(app, document.getElementById('app'));
